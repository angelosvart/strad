{"version":3,"sources":["js/api.js","js/CreateBox.js","js/index.js"],"names":["getText","response","fetch","method","apiData","json","err","console","log","CreateBox","constructor","text","image","init","app","document","querySelector","splitText","split","counter","push","length","div","createElement","classList","add","item","a","h2","img","indexOf","href","dataset","src","setAttribute","innerHTML","appendChild","h3","innerText","loadImages","querySelectorAll","imageObserver","IntersectionObserver","entries","observer","forEach","entry","isIntersecting","target","unobserve","observe","createBox","Promise","resolve","reject","Error"],"mappings":";AAUC,aATM,eAAeA,IACd,IACMC,MAAAA,QAAiBC,MAAM,4CAA6C,CAACC,OAAQ,QAG5EC,aAFeH,EAASI,OAGjC,MAAOC,GACLC,QAAQC,IAAI,kBAAmBF,IAEtC,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,QAAA;;ACR8B,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,aAAA,EAF/B,IAAA,EAAA,QAAA,SAEe,MAAMG,EACjBC,cACSC,KAAAA,KAAO,GAEPC,KAAAA,MAAQ,kCAIXC,aACIC,MAAAA,EAAMC,SAASC,cAAc,QAO7BC,SADc,EAApB,EAAA,YACwB,GAAGC,MAAM,KAE7BC,IAAAA,EAAU,EAGPA,KAAAA,GAAW,IACE,IAAZA,GAA6B,IAAZA,EACZR,KAAAA,KAAKS,KAXlB,sDAc0C,IAA9BH,EAAUE,GAASE,OACfV,KAAAA,KAAKS,KAAKH,EAAU,IAEnBN,KAAAA,KAAKS,KAAKH,EAAUE,IAGjCA,IAIEG,MAAAA,EAAMP,SAASQ,cAAc,OACnCD,EAAIE,UAAUC,IAAI,OAEb,IAAA,MAAMC,KAAQ,KAAKf,KAAM,CACpBgB,MAAAA,EAAIZ,SAASQ,cAAc,KAC3BK,EAAKb,SAASQ,cAAc,MAC5BM,EAAMd,SAASQ,cAAc,OAE/B,GAAA,KAAKZ,KAAKmB,QAAQJ,GAAQ,EAAG,CAQzB,GAPJC,EAAEH,UAAUC,IAAI,OAChBE,EAAEI,KAAF,IACAF,EAAIG,QAAQC,IAAS,GAAA,OAAA,KAAKrB,MAAgB,YAAA,OAAA,KAAKD,KAAKmB,QAAQJ,IAE5DG,EAAIK,aAAa,UAAW,QAC5BN,EAAGO,UAAYT,EACfC,EAAES,YAAYR,GACkB,IAA5B,KAAKjB,KAAKmB,QAAQJ,GAAa,CACzBW,MAAAA,EAAKtB,SAASQ,cAAc,MAClCc,EAAGC,UAAY,OACfX,EAAES,YAAYC,GAElBV,EAAES,YAAYP,GACdf,EAAIsB,YAAYT,QAEhBA,EAAEH,UAAUC,IAAI,YAChBE,EAAEI,KAAF,IACAF,EAAIG,QAAQC,IAAS,GAAA,OAAA,KAAKrB,MAAgB,YAAA,OAAA,KAAKD,KAAKmB,QAAQJ,IAC5DG,EAAIK,aAAa,UAAW,QAC5BN,EAAGO,UAAYT,EACfC,EAAES,YAAYR,GACdD,EAAES,YAAYP,GACdP,EAAIc,YAAYT,GAGxBb,EAAIsB,YAAYd,GAIpBiB,aACQA,IAAAA,EAAaxB,SAASyB,iBAAiB,YAEvCC,EAAgB,IAAIC,qBAAqB,CAACC,EAASC,KACnDD,EAAQE,QAAQC,IACRA,GAAAA,EAAMC,eAAgB,CAClBnC,IAAAA,EAAQkC,EAAME,OAClBpC,EAAMqB,IAAMrB,EAAMoB,QAAQC,IAC1BQ,EAAcQ,UAAUrC,QAKpC2B,EAAWM,QAAQjC,IACf6B,EAAcS,QAAQtC,MAxFH,QAAA,QAAA;;ACE/B,aAJA,IAAA,EAAA,EAAA,QAAA,gBAIA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,MACUuC,MAAAA,EAAY,IAAI1C,EAAJ,QAED,IAAI2C,QAAQ,MAAOC,EAASC,WAEnCH,EAAUtC,OAEZE,SAASyB,iBAAiB,QAAQnB,OAClCgC,EAAQF,EAAUZ,cAElBe,EAAOC,MAAM,4BAVzB","file":"js.bbd7ea08.js","sourceRoot":"../src","sourcesContent":["//Function will fetch random text from API\r\nexport async function getText() {\r\n    try {\r\n        const response = await fetch(\"https://baconipsum.com/api/?type=all-meat\", {method: 'GET'});\r\n        const apiData = await response.json();\r\n\r\n        return apiData;\r\n    } catch (err) {\r\n        console.log('Failed to fetch', err);\r\n    }\r\n}\r\n","import { getText } from './api';\r\n\r\nexport default class CreateBox {\r\n    constructor() {\r\n        this.text = [];\r\n        //For the sake of the test getting random pics from Picsum\r\n        this.image = 'https://picsum.photos/1920/1088';\r\n    }\r\n\r\n    //Init method will get texts from the API and create the boxes\r\n    async init() {\r\n        const app = document.querySelector(\"#app\");\r\n        \r\n        //Adding sale text to create the CSS animation for excercise 4\r\n        const saleText = `Sale <br/> up to <span class=\"animate\"></span> off`;\r\n\r\n        //For the sake of the test getting random text from an API and splitting it in single words\r\n        const texts = await getText();\r\n        const splitText = texts[0].split(\" \");\r\n\r\n        let counter = 1;\r\n\r\n        //Add 10 texts to the array (including sale text in the respective boxes) for all boxes\r\n        while (counter <= 10) {\r\n            if (counter === 1 || counter === 6) {\r\n                this.text.push(saleText);\r\n            } else {\r\n                //Sometimes the API returns double spaces, if so add the 1st item of the array so the box has always text\r\n                if (splitText[counter].length === 0) {\r\n                   this.text.push(splitText[0]);\r\n                } else {\r\n                    this.text.push(splitText[counter]);\r\n                }\r\n            }\r\n            counter++;\r\n        }\r\n        \r\n        //This loop will create all the elements for each box and mini boxes and append them to the DOM\r\n        const div = document.createElement(\"div\");\r\n        div.classList.add(\"box\");\r\n\r\n        for (const item of this.text) {\r\n            const a = document.createElement(\"a\");\r\n            const h2 = document.createElement(\"h2\");\r\n            const img = document.createElement(\"img\");\r\n\r\n            if (this.text.indexOf(item) < 6) {\r\n                a.classList.add(\"box\");\r\n                a.href = `#`;\r\n                img.dataset.src = `${this.image}?random=${this.text.indexOf(item)}`;\r\n                //Adding lazy loading attr for supported browsers\r\n                img.setAttribute(\"loading\", \"lazy\");\r\n                h2.innerHTML = item;\r\n                a.appendChild(h2); \r\n                if (this.text.indexOf(item) === 0) {\r\n                    const h3 = document.createElement(\"h3\");\r\n                    h3.innerText = \"Shop\";\r\n                    a.appendChild(h3)\r\n                }            \r\n                a.appendChild(img);\r\n                app.appendChild(a);\r\n            } else {\r\n                a.classList.add(\"box-mini\");\r\n                a.href = `#`;\r\n                img.dataset.src = `${this.image}?random=${this.text.indexOf(item)}`;\r\n                img.setAttribute(\"loading\", \"lazy\");\r\n                h2.innerHTML = item;\r\n                a.appendChild(h2);\r\n                a.appendChild(img);\r\n                div.appendChild(a);\r\n            }\r\n        }\r\n        app.appendChild(div);\r\n\r\n    }\r\n    //After loading the boxes in the DOM with the texts, using Intersection Observer API to lazy load images while scrolling\r\n    loadImages() {\r\n        let loadImages = document.querySelectorAll(\".box img\");\r\n\r\n        let imageObserver = new IntersectionObserver((entries, observer) => {\r\n            entries.forEach(entry => {\r\n                if (entry.isIntersecting) {\r\n                    let image = entry.target;\r\n                    image.src = image.dataset.src;\r\n                    imageObserver.unobserve(image);\r\n                }\r\n            })\r\n        });\r\n\r\n        loadImages.forEach(image => {\r\n            imageObserver.observe(image)\r\n        });\r\n    }\r\n}\r\n","import CreateBox from './CreateBox';\r\n\r\n//Init function will create instance of CreateBox class and then use a promise to first \r\n//use the init method to load DOM elements and texts from the API and when resolved create observer to lazy load images\r\n(() => {\r\n    const createBox = new CreateBox();\r\n\r\n    const initLoad = new Promise(async (resolve, reject) => {\r\n\r\n        await createBox.init();\r\n\r\n        if (document.querySelectorAll(\".box\").length) {\r\n            resolve(createBox.loadImages())\r\n        } else {\r\n            reject(Error(\"Problem loading data\"))\r\n        }\r\n    });\r\n})();"]}